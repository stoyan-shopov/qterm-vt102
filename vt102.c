/*!
 *	\file	vt102.c
 *	\brief	generic DEC vt102 terminal emulator command parser
 *	\author	shopov
 *
 *	this is a generic DEC vt102 terminal emulator command parser that does
 *	not contain any rendering code for a concrete display device
 *	it is meant to be used as a generic vt102 terminal command parser
 *	which will invoke, as appropriate, an externally supplied display
 *	rendering backend module, thru a well defined interface;
 *	this backend must provide the interface defined in
 *	struct vt102_backend_interface_struct
 *
 *	basically, the backend is responsible for rendering the character
 *	display of the vt102 screen to some display device
 *	(e.g. a character console, a graphics window, etc.)
 *
 *	this module is not concerned with modelling any form of input
 *	from a vt102 device; if some form of user input, such as
 *	keyboard input, is needed, this must be done outside of this module
 *	(probably in the backend)
 *
 *	generally, this module does not invoke any vt102 input-fetching functions
 *	(implying that it will not block waiting for vt102 input); the
 *	code is organized as a large (but simple) state machine, which
 *	expects as input character input to a vt102 device; the state machine
 *	invokes backend functions when appropriately
 *
 *	this module implements the vt102 received character processing
 *	as described in the DEC vt102 user guide available at:
 *
 *	http://www.vt100.net/docs/vt102-ug/
 *
 *	for convenience, appendices C and D of the forementioned manual
 *	are copied here verbatim
 *
 **********************************************************
 **********************************************************
 	start of the verbatim copy of appendix C of
 	the DEC vt102 user guide available at
 	http://www.vt100.net/docs/vt102-ug/
 **********************************************************
 **********************************************************

C Programming Summary
General

This appendix provides a summary of VT102 escape and control sequences.

Figure C-1 shows the codes generated by the standard keys. Figure C-2 shows the control codes generated by the function keys; shaded keys do not need CTRL down to generate the control character.
Programming Sequences

The rest of this appendix repeats the information on the VT102 Programming Reference Card (EK-VT102-RC-001).
Control Characters Received
Name 	Character Mnemonic 	Octal Code 	Function
Null 	NUL 	000 	Ignored when received (not stored in input buffer) and used as a fill character.
End of text 	ETX 	003 	Can be selected as a half-duplex turnaround character.
End of transmission 	EOT 	004 	Can be selected as a disconnect character or half-duplex turnaround character. When used as a turnaround character, the disconnect character is DLE-EOT.
Enquire 	ENQ 	005 	Transmits answerback message.
Bell 	BEL 	007 	Generates bell tone.
Backspace 	BS 	010 	Moves cursor to the left one character position; if cursor is at left margin, no action occurs.
Horizontal tab 	HT 	011 	Moves cursor to next tab stop, or to right margin if there are no more tab stops.
Linefeed 	LF 	012 	Causes a linefeed or a new line operation. (See Linefeed/New Line mode). Also causes printing if auto print operation selected.
Vertical tab 	VT 	013 	Processed as LF.
Form feed 	FF 	014 	Processed as LF. FF can also be selected as a half-duplex turnaround character.
Carriage return 	CR 	015 	Moves cursor to left margin on current line. CR can also be selected as a half-duplex turnaround character.
Shift out 	SO 	016 	Selects G1 character set designated by a select character set sequence.
Shift in 	SI 	017 	Selects G0 character set designated by a select character set sequence.
Device control 1 	DC1 	021 	Processed as XON. DC1 causes terminal to continue transmitting characters.
Device control 3 	DC3 	023 	Processed as XOFF. DC3 causes terminal to stop transmitting all characters except XOFF and XON. DC3 can also be selected as a half-duplex turnaround character.
Cancel 	CAN 	030 	If received during an escape or control sequence, cancels the sequence and displays substitution character ([]).
Substitute 	SUB 	032 	Processed as CAN.
Escape 	ESC 	033 	Processed as a sequence introducer.
ANSI Compatible Sequences
Set Mode
Name 	Mnemonic 	Mode 	Sequence
Keyboard action 	KAM 	Locked 	ESC [ 2 h
Insertion-replacement 	IRM 	Insert 	ESC [ 4 h
Send-receive 	SRM 	Off 	ESC [ 1 2 h
Linefeed/new line 	LMN 	New line 	ESC [ 2 0 h
Cursor key 	DECCKM 	Application 	ESC [ ? 1 h
ANSI/VT52 	DECANM 	ANSI 	N/A
Column 	DECCOLM 	132 column 	ESC [ ? 3 h
Scrolling 	DECSCLM 	Smooth 	ESC [ ? 4 h
Screen 	DECSCNM 	Reverse 	ESC [ ? 5 h
Origin 	DECOM 	Relative 	ESC [ ? 6 h
Auto wrap 	DECAWM 	On 	ESC [ ? 7 h
Auto repeat 	DECARM 	On 	ESC [ ? 8 h
Print form feed 	DECPFF 	On 	ESC [ ? 1 8 h
Print extent 	DECPEX 	Full screen 	ESC [ ? 1 9 h
Reset Mode
Name 	Mnemonic 	Mode 	Sequence*
Keyboard action 	KAM 	Unlocked 	ESC [ 2 l
Insertion-replacement 	IRM 	Replace 	ESC [ 4 l
Send-receive 	SRM 	On 	ESC [ 1 2 l
Linefeed/new line 	LMN 	Linefeed 	ESC [ 2 0 l
Cursor key 	DECCKM 	Cursor 	ESC [ ? 1 l
ANSI/VT52 	DECANM 	VT52 	ESC [ ? 2 l
Column 	DECCOLM 	80 column 	ESC [ ? 3 l
Scrolling 	DECSCLM 	Jump 	ESC [ ? 4 l
Screen 	DECSCNM 	Normal 	ESC [ ? 5 l
Origin 	DECOM 	Absolute 	ESC [ ? 6 l
Auto wrap 	DECAWM 	Off 	ESC [ ? 7 l
Auto repeat 	DECARM 	Off 	ESC [ ? 8 l
Print form feed 	DECPFF 	Off 	ESC [ ? 1 8 l
Print extent 	DECPEX 	Scrolling region 	ESC [ ? 1 9 l
* The last character of the sequence is lowercase L (1548)
Cursor Key Codes Generated
Cursor Key (Arrow) 	ANSI Characters Generated
Reset (Cursor) 	Set (Application)
Up 	ESC [ A 	ESC O A
Down 	ESC [ B 	ESC O B
Right 	ESC [ C 	ESC O C
Left 	ESC [ D 	ESC O D
Keypad Character Selection
Name 	Mnemonic 	Sequence
Alternate 	DECKPAM 	ESC =
Numeric 	DECKPNM 	ESC >
Keypad Codes Generated
Key 	VT52 Numeric Keypad Mode 	VT52 Alternate Keypad Mode 	ANSI Numeric Keypad Mode 	ANSI Alternate Keypad Mode
0 	0 	ESC ? p 	0 	ESC O p

1 	1 	ESC ? q 	1 	ESC O q
2 	2 	ESC ? r 	2 	ESC O r
3 	3 	ESC ? s 	3 	ESC O s
4 	4 	ESC ? t 	4 	ESC O t
5 	5 	ESC ? u 	5 	ESC O u
6 	6 	ESC ? v 	6 	ESC O v
7 	7 	ESC ? w 	7 	ESC O w
8 	8 	ESC ? x 	8 	ESC O x
9 	9 	ESC ? y 	9 	ESC O y
- (minus) 	- (minus) 	ESC ? m 	- (minus) 	ESC O m
, (comma) 	, (comma) 	ESC ? l* 	, (comma) 	ESC O l*
. (period) 	. (period) 	ESC ? n 	. (period) 	ESC O n
ENTER 	Same as RETURN 	ESC ? M 	Same as RETURN 	ESC O M
PF1 	ESC P 	ESC P 	ESC O P 	ESC O P
PF2 	ESC Q 	ESC Q 	ESC O Q 	ESC O Q
PF3 	ESC R 	ESC R 	ESC O R 	ESC O R
PF4 	ESC S 	ESC S 	ESC O S 	ESC O S
* The last character of the sequence is lowercase L (1548)
Select Character Sets SCS
Character Set 	G0 Designator 	G1 Designator
United Kingdom (UK) 	ESC ( A 	ESC ) A
United States (US) 	ESC ( B 	ESC ) B
Special characters and line drawing set 	ESC ( 0 	ESC ) 0
Alternate character ROM 	ESC ( 1 	ESC ) 1
Alternate character ROM - special characters 	ESC ( 2 	ESC ) 2
Name 	Mnemonic 	Sequence
Single shift 2 	SS2 	ESC N
Single shift 3 	SS3 	ESC O
Character Attributes
Name 	Mnemonic 	Sequence
Select graphic rendition (no attributes) 	SGR 	ESC [ m
Select graphic rendition (no attributes) 	SGR 	ESC [ 0 m
Select graphic rendition (select attribute bold) 	SGR 	ESC [ 1 m
Select graphic rendition (select attribute underline) 	SGR 	ESC [ 4 m
Select graphic rendition (select attribute blink) 	SGR 	ESC [ 5 m
Select graphic rendition (select attribute, reverse video) 	SGR 	ESC [ 7 m
Scrolling Region
Name 	Mnemonic 	Sequence
Set top and bottom margins 	DECSTBM 	ESC [ Pt ; Pb r
Cursor Movement Commands
Name 	Mnemonic 	Sequence
Cursor up 	CUU 	ESC [ Pn A
Cursor down 	CUD 	ESC [ Pn B
Cursor forward (right) 	CUF 	ESC [ Pn C
Cursor backward (left) 	CUB 	ESC [ Pn D
Cursor position 	CUP 	ESC [ Pl ; Pc H
Cursor position (home) 	CUP 	ESC [ H
Horizontal and vertical position 	HVP 	ESC [ Pl ; Pc f
Horizontal and vertical position (home) 	HVP 	ESC [ f
Index 	IND 	ESC D
Reverse index 	RI 	ESC M
Next line 	NEL 	ESC E
Save cursor (and attributes) 	DECSC 	ESC 7
Restore cursor (and attributes) 	DECRC 	ESC 8
Tab Stops
Name 	Mnemonic 	Sequence
Horizontal tab set (at current column) 	HTS 	ESC H
Tabulation clear (at current column) 	TBC 	ESC [ g
Tabulation clear (at current column) 	TBC 	ESC [ 0 g
Tabulation clear (all tabs) 	TBC 	ESC [ 3 g
Line Attributes
Name 	Mnemonic 	Sequence
Double-height top half 	DECDHL 	ESC # 3
Double-height bottom half 	DECDHL 	ESC # 4
Single-width single-height 	DECSWL 	ESC # 5
Double-width single-height 	DECDWL 	ESC # 6
Erasing
Name 	Mnemonic 	Sequence
Erase in line (cursor to end of line) 	EL 	ESC [ K
Erase in line (cursor to end of line) 	EL 	ESC [ 0 K
Erase in line (beginning of line to cursor) 	EL 	ESC [ 1 K
Erase in line (entire line containing cursor) 	EL 	ESC [ 2 K
Erase in display (cursor to end of screen) 	ED 	ESC [ J
Erase in display (cursor to end of screen) 	ED 	ESC [ 0 J
Erase in display (beginning of screen to cursor) 	ED 	ESC [ 1 J
Erase in display (entire screen) 	ED 	ESC [ 2 J
Editing Functions
Name 	Mnemonic 	Sequence
Delete character 	DCH 	ESC [ Pn P
Insert line 	IL 	ESC [ Pn L
Delete line 	DL 	ESC [ Pn M
Print Commands
Name 	Mnemonic 	Sequence
Media copy (enter auto print) 	MC 	ESC [ ? 5 i
Media copy (exit auto print) 	MC 	ESC [ ? 4 i
Media copy (enter printer controller) 	MC 	ESC [ 5 i
Media copy (exit printer controller) 	MC 	ESC [ 4 i
Media copy (print screen) 	MC 	ESC [ i
Media copy (print screen) 	MC 	ESC [ 0 i
Media copy (print cursor line) 	MC 	ESC [ ? 1 i
Reports
Name 	Mnemonic 	Sequence
Device status report (request status of VT102) 	DSR 	ESC [ 5 n
Response:
    Terminal OK 	DSR 	ESC [ 0 n
    Terminal not OK 	DSR 	ESC [ 3 n
Device status report (request status of printer) 	DSR 	ESC [ ? 1 5 n
Response:
    Printer ready 	DSR 	ESC [ ? 1 0 n
    Printer not ready 	DSR 	ESC [ ? 1 1 n
    No printer 	DSR 	ESC [ ? 1 3 n
Device status report (report cursor position) 	DSR 	ESC [ 6 n
Cursor position report 	CPR 	ESC [ Pl ; Pc R
Device attributes (what are you) 	DA 	ESC [ c
Device attributes (what are you) 	DA 	ESC [ 0 c
Identify terminal (what are you) 	DECID 	ESC Z

NOTE: ESC Z is not recommended.
Device attributes response: VT102 	DA 	ESC [ ? 6 c
Reset
Name 	Mnemonic 	Sequence
Reset to initial state 	RIS 	ESC c
Tests and adjustments
Name 	Mnemonic 	Sequence
Screen alignment display (fill screen with "Es") 	DECALN 	ESC # 8
Invoke confidence test (power-up test) 	DECTST 	ESC [ 2 ; 1 y
Invoke confidence test (data loopback test; requires test connector) 	DECTST 	ESC [ 2 ; 2 y
Invoke confidence test (EIA modem control test; requires test connector) 	DECTST 	ESC [ 2 ; 4 y
Invoke confidence test (repeat power-up test continuously until failure or power-off) 	DECTST 	ESC [ 2 ; 9 y
Invoke confidence test (repeat data loopback test continuously until failure or power-off; requires test connector) 	DECTST 	ESC [ 2 ; 1 0 y
Invoke confidence test (repeat EIA test continuously until failure or power-off; requires test connector) 	DECTST 	ESC [ 2 ; 1 2 y
Invoke confidence test (printer port data loopback test; requires test connector) 	DECTST 	ESC [ 2 ; 1 6 y
Invoke confidence test (repeat printer port data loopback test continuously until failure or power-off; requires test connector) 	DECTST 	ESC [ 2 ; 2 4 y
Keyboard LEDs
Name 	Mnemonic 	Sequence
Load LEDs (L1 off) 	DECLL 	ESC [ q
Load LEDs (L1 off) 	DECLL 	ESC [ 0 q
Load LEDs (L1 on) 	DECLL 	ESC [ 1 q
VT52 Compatible Mode
Modes 	Sequence
Enter ANSI mode 	ESC <
Keypad Character Selection
Name 	Sequence
Enter alternate keypad mode 	ESC =
Exit alternate keypad mode (Numeric keypad mode) 	ESC >

NOTE: VT52 alternate keypad and numeric keypad mode different than ANSI.
Character Sets
Name 	Sequence
Special graphics character set 	ESC F*
Select US/UK character set (as determined by the US/UK character SET-UP feature) 	ESC G
* Same as special character and line drawing set in ANSI mode.
Cursor Position
Name 	Sequence
Cursor up* 	ESC A
Cursor down* 	ESC B
Cursor right* 	ESC C
Cursor left* 	ESC D
Cursor to home 	ESC H
Direct cursor address 	ESC Y Pl Pc†
Reverse line feed 	ESC I‡
* Same when sent from the terminal.
† Line and column numbers for direct cursor address are single character codes whose values are the desired number plus 378.
Line and colum numbers start at one.
‡ The last character of the sequence is an uppercase i (1118).
Erasing
Name 	Sequence
Erase to end of line 	ESC K
Erase to end of screen 	ESC J
Print Commands
Name 	Sequence
Enter auto print mode 	ESC ^
Exit auto print mode 	ESC _
Enter printer controller mode 	ESC W
Exit printer controll mode 	ESC X
Print screen 	ESC ]
Print cursor line 	ESC V
Reports
Name 	Sequence
Identify (what are you) 	ESC Z
Response: VT102 (same as VT52) 	ESC / Z


 **********************************************************
 **********************************************************
 	end of the verbatim copy of appendix C of
 	the DEC vt102 user guide available at
 	http://www.vt100.net/docs/vt102-ug/
 **********************************************************
 **********************************************************


 **********************************************************
 **********************************************************
 	start of the verbatim copy of appendix D of
 	the DEC vt102 user guide available at
 	http://www.vt100.net/docs/vt102-ug/
 **********************************************************
 **********************************************************

D Control Functions (Sequence Formats)
General

This appendix summarizes the ANSI code extension techniques defined in standards X3.41-1974 and X3.64-1979. Those specifications cover many special cases and details not included here.
Control Functions

The ANSI standards define types of characters used for specific purposes. You can determine a character's type by its position in the ASCII table (Table D-1). There are two general categories of characters:

    * display (columns 2 through 7)
    * control (columns 0 and 1).

This table and the ANSI system can work for either a 7-bit or 8-bit character environment. The VT102 uses only 7-bit characters.

NOTE: The ASCII 7-bit table corresponds to International Standards Organization (ISO) standard 646 and International Telegraph and Telephone Consultive Committee (CCITT) alphabet 5.

All control characters and groups of characters (sequences) not intended for display on the screen are control functions. Not all control functions perform an action in every ANSI device, but each device can recognize all control functions and discard any that do not apply to it. Therefore, each device performs a subset of the ANSI functions.

Because different devices use different subsets, compliance with ANSI does not mean compatibility between devices. Compliance only means that a particular function, if defined in the ANSI standard, is invoked by the same control function in all devices. If an ANSI device does not perform an action that has a control function defined in the ANSI standard, it cannot use that control function for any other purpose.
Escape and Control Sequences

Escape and control sequences provide more controls in addition to the control characters in the ASCII 7-bit table. These multiple-character control sequences are not displayed but control the displaying, processing, and transmission of characters. At the end of a sequence or during an error condition, the terminal continues to display received characters. See Error Recovery in Chapter 5 for specific error conditions.
Escape Sequences

The format for an escape sequence is as follows.

ESC           I.....I         F
033           040-057         060-176

Escape        Intermediate    Final
sequence      characters      character
introducer    (0 or more      (1 character)
              characters)

Escape Sequence Introducer

    This is the ESC character (octal 033) defined by ANSI X3.4-1977. After receiving ESC, the terminal stores (but does not display) all control characters received in the proper range.
Intermediate Characters

    These are characters received after ESC in the octal range of 040 - 057 (column 2 of the ASCII table). The terminal stores intermediate characters as part of the control function.
Final Character

    This is a character received after ESC in the octal range of 060 - 176 (columns 3 - 7 of the ASCII table). The final character indicates the end of the control function. The intermediate and final characters together define the function of the sequence. The terminal then performs the specified function and continues to display received characters. ANSI standard control functions have a final character in the octal range of 100 - 176 (columns 4 - 7 of the ASCII table). Private sequences have a final character in the octal range of 060 - 077 (column 3 of the ASCII table).

Example

Action: Designate ASCII character set as G0.
Sequence

ESC   (    B
033  050  102
 |    |    |
 |    |    +------- Final Character
 |    +------------ Intermediate Character
 +----------------- Escape Sequence Introducer

Control Sequence Format

The format of a control sequence is as follows.

CSI           P.....P        I.....I         F
033 133       060-077        040-057         100-176

Control       Parameter      Intermediate    Final character
sequence      characters     characters      (1 character)
introducer    (0 or more     (0 or more
              characters)    characters)

Control Sequence Introducer

    The CSI is the ESC (octal 033) and [ (octal 133) characters defined by ANSI X3.41-1977. These characters provide 8-bit control functions by using 7-bit characters. The VT102 supports only 7-bit characters. After receiving CSI characters, the terminal stores (but does not display) all control characters received in the proper range.
Parameter Characters

    These are characters received after the CSI character, in the octal range of 060 - 077 (column 3 of the ASCII table). The parameter characters modify the action or interpretation of the control function. The terminal interprets parameter characters as private when the < = > ? characters (octal 074 - 077) begin the paramter string. The : character (octal 072) is reserved. This means an ANSI-specified control sequence can have a parameter function with a private interpretation.

    The terminal uses two types of parameter characters, numeric and selective. A numeric parameter represents a decimal number, designated by Pn. The decimal characters have a range of 0 - 9 (octal 060 - 071). A selective parameter comes from a list of specified parameters, designated by Ps.

    If a control sequence includes more than one parameter, the parameters are separated by a delimiter, the ; character (octal 073).
Intermediate Characters

    These are characters received after the CSI character, in the octal range of 040 - 057 (column 2 of the ASCII table). The terminal stores these characters as part of the control function.

    NOTE: The terminal does not use intermediate characters in control functions.
Final Character

    This is a character received after the CSI character, in the octal range of 100 - 176 (columns 4 - 7 of the ASCII table). The final character indicates the end of the control function. The intermediate and final characters together define the function of the sequence. The terminal then performs the specified function and continues to display received characters. ANSI standard control functions have a final character in the octal range of 100 - 157 (columns 4 - 6 of the ASCII table). Private sequences have a final character in the octal range of 160 - 176 (column 7 of the ASCII table).

Example

Action: Clear all horizontal tabs.
Sequence

ESC   [    3    g
033  133  063  147
 |    |    |    |
 +--+-+    |    |
    |      |    +----- Final Character
    |      +---------- Parameter Character
    +----------------- Control Sequence Introducer

Sequence Examples

These examples show the use of multiple functions selected in one sequence, private parameters and private sequences.

ESC   [    ?    4    h          Set smooth scroll mode
033  133  077  064  150         (? = ANSI private parameter)

ESC   [    2    ;    1    y     Invoke self-test
033  133  062  073  061  171    (y = ANSI private sequence)


 **********************************************************
 **********************************************************
 	end of the verbatim copy of appendix D of
 	the DEC vt102 user guide available at
 	http://www.vt100.net/docs/vt102-ug/
 **********************************************************
 **********************************************************
 *
 *	following is the beginning of chapter 5
 *	(received character processing) of the
 *	DEC vt102 manual; the error recovery model
 *	described there is adopted by the
 *	code in this module
 *
 **********************************************************
 **********************************************************
 	start of the verbatim copy of the beginning of
 	chapter 5 in the DEC vt102 user guide available at
 	http://www.vt100.net/docs/vt102-ug/
 **********************************************************
 **********************************************************
5 Received Character Processing
General

This chapter describes how the VT102 processes received characters. There are two types of received characters, display characters and control functions. The chapter covers all display characters and control functions used by the terminal.
Received Characters

The terminal processes characters according to American National Standards Institute (ANSI) standards X3.64-1979, X3.4-1977, and X3.41-1974. ANSI standard X3.4 defines the American Standard Code for Information Interchange (ASCII). Table 5-1 shows each ASCII character with its binary, octal, decimal, and hexadecimal values. ASCII corresponds to the International Standards Organization (ISO) Standard 646 and International Telegraph and Telephone Consultative Committee (CCITT) Alphabet 5.

The terminal processes a received character based on character types defined by ANSI. Position in the ASCII table tells you whether a character is a control function or display character. The ASCII table is 8 columns wide and 16 rows long. The control functions are in columns 0 and 1. The display characters are in columns 2 through 7. However, the terminal uses space (SP) as either an information separator control function or display character. Delete (DEL) is always a control function.
Display Characters

Display characters are received characters displayed on the screen. The actual character displayed depends on the character set selected. You select the character set by using control functions. See Character Sets and Selection in this chapter for more information.
Control Characters

These single-character control functions start, modify, or stop terminal operations; the control functions are not displayed. Table 5-2 defines the control characters recognized by the terminal. All other control characters are ignored.

Each control character in this chapter has a mnemonic, listed in Table 5-2. The mnemonic is an abbreviation of the control character name.
Escape and Control Sequences

Escape and control sequences provide additional control functions not provided by the single-character controls of the character set. These multiple-character sequences are not displayed; instead, they control terminal operation. Escape and control sequences are defined by ANSI X3.41-1977 and X3.64-1979. See Appendix D for more information about sequences and sequence formats.

The terminal provides upward and downward software compatibility. It can respond to control functions created to meet private DIGITAL standards and present ANSI standards. Therefore, you can use existing software designed for previous terminals (such as the VT52), or new software designed for ANSI standards. However, future video terminals may not accept private DIGITAL sequences. Therefore, all new software should use ANSI-compatible sequences.

The terminal uses VT52 mode to respond to private DIGITAL sequences like a VT52 terminal.

The terminal uses ANSI mode to respond to a subset of control functions specified by ANSI. All control functions not presently specified by ANSI are created to comply with the extensions permitted by ANSI standards. These sequences are considered ANSI private sequences.

The ANSI-compatible control functions in this user guide have a mnemonic assigned by ANSI. If the control function is an ANSI private control function (defined by DIGITAL), the mnemonic begins with DEC. The escape and control sequences shown here use ASCII characters. You must type the characters in the sequences exactly as shown (upper or lowercase). The text provides the octal equivalent of each character in the sequence as a second reference. See Table 5-1 for decimal and hexadecimal representations.

The following section groups sequences by software compatibility (ANSI or VT52) and function (Table 5-3). Appendix C summarizes all control functions.
Error Recovery

Current standards do not specify the action performed when the terminal receives a control function with an error. Errors are incorrect parameters, invalid control functions, or control characters embedded in control function sequences. The terminal usually recovers from these errors by performing as much of the function as possible. The specific error recovery procedures are as follows.

    * Unrecognized control functions are usually ignored.
    * Unsupported control functions (valid control functions not listed in this user guide) are usually ignored, but may produce unexpected results.
    * If a control character is received within a sequence, the terminal performs the function of the control character, followed by the function of the sequence.
    * If cancel (CAN, octal 030) or substitute (SUB, octal 032) is received during a sequence, the current sequence is aborted. The terminal displays the substitute character, followed by characters in the sequence received after CAN or SUB.

ANSI-Compatible Sequences

ANSI-compatible sequences meet ANSI standards X3.64-1979 and X3.41-1974. This section describes the ANSI control functions used by the terminal. You can select ANSI compatibility from the keyboard in SET-UP (Chapter 3) or have the computer use a sequence. (See VT52-Compatible Sequences in this chapter).
SET-UP Feature and Mode Selection

SET-UP features change how the terminal operates. You can select these features from the keyboard in SET-UP. The computer can select some SET-UP features by using control functions. However, features selected by the computer are stored in operating memory. The computer cannot store feature selections in user memory. (See Chapter 3 for more information about SET-UP feature memories).

Some SET-UP features are modes. A mode affects terminal operation. The terminal uses the selected mode until you or the computer change the selection. Table 5-4 lists SET-UP features and modes. The computer changes modes by using set mode (SM) and reset mode (RM) sequences. Set and reset the terminal modes by using the following sequences.

NOTE: Ps represents a variable parameter selected from a list of parameters. A series of asterisks (***) represent the parameter in the octal sequence. The parameter is transmitted using ASCII characters. When you set several modes with a single SM or RM sequence, a semicolon (;, octal 073) separates parameters.

Set Mode

ESC  [  Ps   ;  ...  ;  Ps   h
033 133 *** 073     073 *** 150

Sets one or more modes specified by selective parameters (Ps) in the parameter string.

Reset Mode (RM)

ESC  [  Ps   ;  ...  ;  Ps   l
033 133 *** 073     073 *** 154

Resets one or more modes specified by selective parameters (Ps) in the parameter string.

Table 5-5 lists the ANSI-specified modes and their selective parameters (Ps). Table 5-6 lists the ANSI-compatible private modes and their selective parameters. When you change ANSI-compatible private modes, the first character in the parameter string is a question mark (?, octal 077). All parameters in the sequence are interpreted as ANSI compatible private parameters. This chapter explains each mode in detail and provides the sequences to set and reset each mode.

The following example shows the use of the question mark (used with ANSI private parameters) and semicolon (used with multiple parameters). The sequence sets both column and scroll modes.

ESC  [   ?   3   ;   4   h
033 133 077 063 073 064 150

Table 5-7 describes modes specified in ANSI X3.64-1979 that are permanently set, permanently reset, or not applicable. See the ANSI standard for more information about these modes.
 **********************************************************
 **********************************************************
 	end of the verbatim copy of the beginning of
 	chapter 5 in the DEC vt102 user guide available at
 	http://www.vt100.net/docs/vt102-ug/
 **********************************************************
 **********************************************************
 *
 *
 *	\todo	not all vt102 terminal commands are currently handled
 *
 *	Revision summary:
 *
 *	$Log: $
 */


/*
 *
 * include section follows
 *
 */
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include "vt102.h"

/*
 *
 * local constants follow
 *
 */

//#define panic(msg) do { printf("%i\n", __LINE__); while(1); } while(0)

extern dtrace(char * msg, int line);
#define panic(msg)	do { dtrace(msg, __LINE__); while (0); } while (0)

/*! the maximum length of an ansi command string that can be handled
 *
 * \todo	this is currently arbitrary - maybe put
 *		a more well-defined value here */
//static const int MAX_ANSI_CMD_LEN = 32;
#define MAX_ANSI_CMD_LEN 32
/*! the maximum number of parameters supported in an ansi command string */
static const int MAX_NR_ANSI_CMD_PARAMS = 32;

/*
 *
 * local data types follow
 *
 */

/*! an enumeration of the subset of ansi control characters supported by the vt102 */
enum
{
/* Null 		*/ ANSI_NUL = 	000,/* 	Ignored when received (not stored in input buffer) and used as a fill character.*/
/* End of text 		*/ ANSI_ETX = 	003,/* 	Can be selected as a half-duplex turnaround character.*/
/* End of transmission 	*/ ANSI_EOT = 	004,/* 	Can be selected as a disconnect character or half-duplex turnaround character. When used as a turnaround character, the disconnect character is DLE-EOT.*/
/* Enquire 		*/ ANSI_ENQ = 	005,/* 	Transmits answerback message.*/
/* Bell 		*/ ANSI_BEL = 	007,/* 	Generates bell tone.*/
/* Backspace 		*/ ANSI_BS = 	010,/* 	Moves cursor to the left one character position; if cursor is at left margin, no action occurs.*/
/* Horizontal tab 	*/ ANSI_HT = 	011,/* 	Moves cursor to next tab stop, or to right margin if there are no more tab stops.*/
/* Linefeed 		*/ ANSI_LF = 	012,/* 	Causes a linefeed or a new line operation. (See Linefeed/New Line). Also causes printing if auto print operation is selected.*/
/* Vertical tab 	*/ ANSI_VT = 	013,/* 	Processed as LF.*/
/* Form feed 		*/ ANSI_FF = 	014,/* 	Processed as LF. FF can also be selected as a half-duplex turnaround character.*/
/* Carriage return 	*/ ANSI_CR = 	015,/* 	Moves cursor to left margin on current line. CR can also be selected as a half-duplex turnaround character.*/
/* Shift out 		*/ ANSI_SO = 	016,/* 	Selects G1 character set designated by a select character set sequence.*/
/* Shift in 		*/ ANSI_SI = 	017,/* 	Selects G0 character set designated by a select character set sequence.*/
/* Device control 1 	*/ ANSI_DC1 = 	021,/* 	Processed as XON. DC1 causes terminal to continue transmitting characters.*/
/* Device control 3 	*/ ANSI_DC3 = 	023,/* 	Processed as XOFF. DC3 causes terminal to stop transmitting all characters except XOFF and XON. DC3 can also be selected as a half-duplex turnaround character.*/
/* Cancel 		*/ ANSI_CAN = 	030,/* 	If received during an escape or control sequence, cancels the sequence and displays substitution character ([]).*/
/* Substitute 		*/ ANSI_SUB = 	032,/* 	Processed as CAN.*/
/* Escape 		*/ ANSI_ESC = 	033,/* 	Processed as a sequence introducer.*/
};




 /*! state variables-holding data structure used by the main vt102 command parser state machine */
struct vt102_state
{
	/*! vt102 command parser state enumeration */
	enum
	{
		/*! invalid state - used for catching errors */
		VT102_STATE_INVALID		= 0,
		/*! the state machine is in a 'normal' input state - that is, it does not currently process any escaped command sequence */
		VT102_STATE_NORMAL_INPUT,
		/*! an escape sequence has been started
		 *
		 * an ESC character has been detected, the
		 * state machine is waiting for more
		 * characters in order to determine what
		 * particular command must be processed */
		VT102_STATE_ESCAPE_SEQUENCE_STARTED,
		/*! the state machine is reading an ecma-48 ansi command sequence
		 *
		 * the state machine is reading characters
		 * following an already detected ansi CSI sequence
		 * (control sequence introducer - ESC '[') */
		VT102_STATE_ANSI_CMD_READ,
	}
	state;
	/*! the buffer holding a complete ansi command string
	 *
	 * the CSI (control sequence introducer bytes - ESC '[')
	 * are not stored here */
	unsigned char cmd[MAX_ANSI_CMD_LEN];
	/*! the index in the cmd buffer above of the first character past the command string already stored in the cmd buffer */
	int cmd_idx;
	/*! the data structure holding the interface to a vt102 terminal emulator backend */
	struct vt102_backend_ops * backend_ops;
};

/*
 *
 * local functions follow
 *
 */

/*!
 *	\fn	static void handle_control_char(struct vt102_state * state, unsigned int input_char)
 *	\brief	handles received ansi control characters
 *
 *	\param	state	the vt102 state variable
 *	\param	input_char	the input character received
 *	\return	none */
static void handle_control_char(struct vt102_state * state, unsigned int input_char)
{
	switch (input_char)
	{
		/* Null 		*/ case ANSI_NUL:/* 	Ignored when received (not stored in input buffer) and used as a fill character.*/
                        /*!	\todo	handle this properly!!! */
			////!!!!panic("");
			break;
		/* End of text 		*/ case ANSI_ETX:/* 	Can be selected as a half-duplex turnaround character.*/
                        /*!	\todo	handle this properly!!! */
                        ////!!!!panic("");
			break;
		/* End of transmission 	*/ case ANSI_EOT:/* 	Can be selected as a disconnect character or half-duplex turnaround character. When used as a turnaround character, the disconnect character is DLE-EOT.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Enquire 		*/ case ANSI_ENQ:/* 	Transmits answerback message.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Bell 		*/ case ANSI_BEL:/* 	Generates bell tone.*/
                        /*!	\todo	handle this properly!!! */
                        ////!!!! panic("");
			break;
		/* Backspace 		*/ case ANSI_BS:/* 	Moves cursor to the left one character position; if cursor is at left margin, no action occurs.*/
			state->backend_ops->handle_backspace(state->backend_ops->param);
			break;
		/* Horizontal tab 	*/ case ANSI_HT:/* 	Moves cursor to next tab stop, or to right margin if there are no more tab stops.*/
                        state->backend_ops->handle_horiz_tab(state->backend_ops->param, state);
			break;
		/* Linefeed 		*/ case ANSI_LF:/* 	Causes a linefeed or a new line operation. (See Linefeed/New Line). Also causes printing if auto print operation is selected.*/
			state->backend_ops->handle_linefeed(state->backend_ops->param);
			break;
		/* Vertical tab 	*/ case ANSI_VT:/* 	Processed as LF.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Form feed 		*/ case ANSI_FF:/* 	Processed as LF. FF can also be selected as a half-duplex turnaround character.*/
			state->backend_ops->handle_linefeed(state->backend_ops->param);
			break;
		/* Carriage return 	*/ case ANSI_CR:/* 	Moves cursor to left margin on current line. CR can also be selected as a half-duplex turnaround character.*/
			state->backend_ops->handle_carriage_return(state->backend_ops->param);
			break;
		/* Shift out 		*/ case ANSI_SO:/* 	Selects G1 character set designated by a select character set sequence.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Shift in 		*/ case ANSI_SI:/* 	Selects G0 character set designated by a select character set sequence.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Device control 1 	*/ case ANSI_DC1:/* 	Processed as XON. DC1 causes terminal to continue transmitting characters.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Device control 3 	*/ case ANSI_DC3:/* 	Processed as XOFF. DC3 causes terminal to stop transmitting all characters except XOFF and XON. DC3 can also be selected as a half-duplex turnaround character.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Cancel 		*/ case ANSI_CAN:/* 	If received during an escape or control sequence, cancels the sequence and displays substitution character ([]).*/
                        /*!	\todo	handle this properly!!! */
                        /*!	\todo	handle this properly!!! */
                        ////!!!!panic("");
			break;
		/* Substitute 		*/ case ANSI_SUB:/* 	Processed as CAN.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		/* Escape 		*/ case ANSI_ESC:/* 	Processed as a sequence introducer.*/
                        /*!	\todo	handle this properly!!! */
                        //panic("");
			break;
		default:
			/* ignore */
			;
	}
}

/*!
 *	\fn	static bool is_displayable(unsigned int input_char)
 *	\brief	tells if a character is not a control character (i.e., outside the range 0x00 - 0x1f)
 *
 *	\param	input_char	the input character
 *	\return	true, if the input character is not a control character
 *		(i.e. when it is in the range 0x20 - 0x7f), false otherwise
 *		(i.e. when it is a control character in the range 0x00 - 0x1f) */
static bool is_displayable(unsigned int input_char)
{
	return input_char > 0x1f;
}

/*!
 *	\fn	static inline void put_in_cmd_buf(struct vt102_state * state, int input_char)
 *	\brief	puts a character in the ansi command buffer of the state passed, performing various checks
 *
 *	\param	state	the vt102 state variable in which the command buffer
 *			resides
 *	\param	input_char	the character to put in the buffer
 *	\return	none */
static inline void put_in_cmd_buf(struct vt102_state * state, int input_char)
{
	if (state->cmd_idx >= MAX_ANSI_CMD_LEN)
	{
		panic("");
	}
	state->cmd[state->cmd_idx++] = input_char;
}

/*!
 *	\fn	static void process_ansi_cmd(struct vt102_state * state)
 *	\brief	processes a completely received ansi command string
 *
 *	\todo	document error handling
 *
 *	this function takes as input a complete ansi command string,
 *	extracts any command parameters, and executes the command requested
 *
 *	\param	state	the vt102 state variable in which the command
 *			buffer resides
 *	\return	none */
static void process_ansi_cmd(struct vt102_state * state)
{
int nr_params;
int cmd_params[MAX_NR_ANSI_CMD_PARAMS];
int i;
/* this variable holds the numerical parameter currently extracted */
int param;
unsigned char c;
bool is_private_param;
/* the generic parameter value used when invoking functions from the backend */
void * backend_param;
bool is_scanning_param;


	printf("%s(): ", __func__);
	for (i = 0; i < state->cmd_idx; i++)
		printf("%i ", state->cmd[i]);

	/* zero-out parameters value by default */
	memset(cmd_params, 0, sizeof cmd_params);
	i = nr_params = param = 0;
	is_scanning_param = is_private_param = false;
	/* extract ansi command parameters */
	/* see if this is the start of a
	 * private parameter sequence (first character in
	 * the range 0x3c - 0x3f) */
	if (0x3c <= state->cmd[0] && state->cmd[0] <= 0x3f)
	{
		is_private_param = true;
		/* skip to next character */
		i++;
	}
	while (i < state->cmd_idx)
	{
		/* get the next byte from the command string */
		c = state->cmd[i++];
		/* see if this is a parameter delimiter */
		if (c == ';')
		{
			is_scanning_param = true;
			if (nr_params == MAX_NR_ANSI_CMD_PARAMS)
				panic("");
			cmd_params[nr_params++] = param;
			param = 0;
			continue;
		}
		/* see if this is a numerical parameter character */
		if (0x30 <= c && c <= 0x3f)
		{
			is_scanning_param = true;
			if (0x3a <= c && c <= 0x3f)
				panic("");
			param *= 10;
			param += c - 0x30;
		}
		else
		{
			/* assume this is the end of the parameter list -
			 * the final (command) character */
			if (is_scanning_param)
			{
				if (nr_params == MAX_NR_ANSI_CMD_PARAMS)
					panic("");
				cmd_params[nr_params++] = param;
			}
			break;
		}
	}
	/* the vt102 does not support intermediate characters, so expect
	 * processing has arrived at the final character */
	if (i != state->cmd_idx)
	{
		////!!!!panic("");
		return;
	}

	backend_param = state->backend_ops->param;
	/* extract the final character (the command character)
	 * and process it */
	switch (c)
	{
		case 'h':
			/* SM - set mode */
			////!!!!panic("");
#if 0
			{ int j; for (j = 0; j <= i; j++) cmd_params[j] += '0'; }
			panic(cmd_params);cmd_params[i] = 0; panic(cmd_params);
			panic("");
#endif
			printf("set mode: ");
			for (i = 0; i < nr_params; i++)
				printf("%i ", cmd_params[i]);
			break;
		case 'l':
			/* RM - reset mode */
			////!!!!panic("");
                        panic("");
                        printf("reset mode: ");
			for (i = 0; i < nr_params; i++)
				printf("%i ", cmd_params[i]);
			break;
		case 'm':
			/* SGR - select graphic rendition */
			/* Selecting an attribute does not turn off other attributes already selected. After you select an attribute, all characters received by the terminal appear with that attribute. If you move the characters by scrolling, the attribute moves with the characters. Select the character attributes by using the following sequences. */
			if (nr_params == 0)
				/* parameter default value */
				nr_params = 1;
			state->backend_ops->select_graphic_rendition(backend_param,
					cmd_params,
					nr_params);
			break;
		case 'r':
			/* DECSTBM - set top and bottom margins (scrolling region) */
			state->backend_ops->set_top_and_bottom_margins(backend_param,
					cmd_params[0] - 1,
					cmd_params[1] - 1);
			break;

		/* cursor movement commands */
		case 'A':
			/* CUU - cursor up
			 *
			 * Moves cursor up Pn lines in same column. Cursor stops at top margin. */
			if (nr_params == 0)
				/* parameter default value */
				i = 1;
			else
				i = cmd_params[0];
                        state->backend_ops->move_cursor_relative(backend_param, 0, -i);
			break;
		case 'B':
			/* CUD - cursor down */
			if (nr_params == 0)
				/* parameter default value */
				i = 1;
			else
				i = cmd_params[0];
			state->backend_ops->move_cursor_relative(backend_param, 0, i);
			break;
		case 'C':
			/* CUF - cursor forward(right) */
			if (nr_params == 0)
				/* parameter default value */
				i = 1;
			else
				i = cmd_params[0];
			state->backend_ops->move_cursor_relative(backend_param, i, 0);
			break;
		case 'D':
			/* CUB - cursor backward(left) */
			if (nr_params == 0)
				/* parameter default value */
				i = 1;
			else
				i = cmd_params[0];
			state->backend_ops->move_cursor_relative(backend_param, -i, 0);
			break;
		case 'H':
			/* CUP - identical to HVP */
			/* CUP - cursor position */
			/* move home if no parameters, otherwise -
			 * parameters Pl; Pc */
			state->backend_ops->move_cursor_absolute(backend_param, cmd_params[1] - 1, cmd_params[0] - 1);
			break;
		case 'f':
			/* HVP - identical to CUP */
			/* HVP - horizontal and vertical position */
			/* move home if no parameters, otherwise -
			 * parameters Pl; Pc */
			panic("");
			break;
		/* tab stops */
		case 'g':
			/* miscellaneous tabulation commands */
			panic("");
			break;

		/* erasing */
		/* from the DEC vt102 manual:

			Erasing removes characters from the screen without affecting other characters on the screen. Erased characters are lost. The cursor position does not change when erasing characters or lines.

			If you erase a line by using the erase in display (ED) sequence, the line attribute becomes single-height, single-width. If you erase a line by using the erase in line (EL) sequence, the line attribute is not affected.

			Erasing a character also erases any character attribute of the character.
		*/
		/*! \note	in all erasures, the character at the cursor position
		 *		is included in the erasure */
		case 'K':
			/* EL - erase in line */
			if (nr_params == 0)
			{
				/* EL - erase in line (cursor to end of line) */
				state->backend_ops->erase_line_from_cursor_to_end(backend_param);
			}
			else if (nr_params == 1)
			{
				switch (cmd_params[0])
				{
					case 0:
						/* EL - erase in line (cursor to end of line) */
						panic("");
						break;
					case 1:
						/* EL - erase in line (beginning of line to cursor) */
						state->backend_ops->erase_line_from_beginning_to_cursor(backend_param);
						break;
					case 2:
						/* EL - erase in line (entire line containing cursor) */
						panic("");
						break;
					default:
						panic("");
				}
			}
			else
				panic("");
			break;

		case 'J':
			/* ED - erase in display */
			if (nr_params == 0)
			{
				/* ED - erase in display (cursor to end of screen) */
				state->backend_ops->erase_display_from_cursor_to_end(backend_param);
			}
			else if (nr_params == 1)
			{
				switch (cmd_params[0])
				{
					case 0:
						/* ED - erase in display (cursor to end of screen) */
						panic("");
						break;
					case 1:
						/* ED - erase in display (beginning of screen to cursor) */
						panic("");
						break;
					case 2:
						/* ED - erase in display (entire screen) */
						state->backend_ops->erase_display(backend_param);
						break;
					default:
						panic("");
				}
			}
			else
				panic("");
			break;
		/* editing functions */
		case 'P':
			/* DCH - delete character */
			/* Deletes Pn characters, starting with the character at cursor position. When a character is deleted, all characters to the right of cursor move left. This creates a space character at right margin. This character has same character attribute as the last character moved left. */
                        state->backend_ops->delete_characters_at_cursor(backend_param,
                                        cmd_params[0] ? cmd_params[0] : 1);
			break;
		case 'L':
			/* IL - insert line */
			/* Inserts Pn lines at line with cursor. Lines displayed below cursor move down. Lines moved past the bottom margin are lost. This sequence is ignored when cursor is outside scrolling region. */
			state->backend_ops->insert_lines_at_cursor(backend_param,
					cmd_params[0] ? cmd_params[0] : 1);
			break;
		case 'M':
			/* DL - delete line */
			/* Deletes Pn lines, starting at line with cursor. As lines are deleted, lines displayed below cursor move up. Lines added to bottom of screen have spaces with same character attributes as last line moved up. This sequence is ignored when cursor is outside scrolling region. */
			state->backend_ops->delete_lines_at_cursor(backend_param,
					cmd_params[0] ? cmd_params[0] : 1);
			break;
		/* print commands - not supported */
		case 'i':
			/* MC - media copy */
			panic("");
			break;
		/* reports */
		case 'n':
			/* DSR - device status report */
			panic("");
			break;
		case 'R':
			/* CPR - cursor position report */
			panic("");
			break;
		case 'c':
			/* DA - device attributes (what are you) */
			if (cmd_params[0] != 0 || nr_params > 1)
			{
				/* ignore command */
			}
			else ;
				state->backend_ops->query_terminal_id(backend_param);
			break;
		/* tests and adjustments */
		case 'y':
			panic("");
			break;
		/* keyboard leds */
		case 'q':
			panic("");
			break;
                /*! \todo	this is not really supported by the vt102 */
                case 'G':
                        /* CHA - cursor character absolute - move the cursor to
                         *		the specified absolute position in the
                         *		current line */
                        if (nr_params == 0)
                                /* parameter default value */
                                i = 1;
                        else
                                i = cmd_params[0];
                        state->backend_ops->move_cursor_column_absolute(state->backend_ops->param, i - 1);
                        break;
                /*! \todo	this is not really supported by the vt102 */
                case 'b':
                        /* repeat */
                        if (nr_params == 0)
                                /* parameter default value */
                                i = 1;
                        else
                                i = cmd_params[0];
                        /*! \todo	this is arbitrary */
                        if (i > 1024)
                                i = 1024;
                        while (i > 0)
                                state->backend_ops->display_char(state->backend_ops->param, 'x', state), i--;
                        break;
	}
}

/*
 *
 * exported functions follow
 *
 */

/*!
 *	\fn	void vt102_command_input_parser(struct vt102_state * state, unsigned int input_char)
 *	\brief	the main vt102 command parser state machine
 *
 *	\param	state		the state machine state variable
 *	\param	input_char	the input character to process
 *	\return	none */
void vt102_command_input_parser(struct vt102_state * state, unsigned int input_char)
{

	/* normalize the input character - strip the eighth bit */
	/*! \todo	is this correct */
	if (input_char & 0x80)
	{
		printf("warning: bit 7 set ");
	}
	input_char &= 0x7f;
	if (input_char == 27)
	{
		state->state = VT102_STATE_NORMAL_INPUT;
	}
	switch (state->state)
	{
		case VT102_STATE_INVALID:
			panic("");
			break;
		case VT102_STATE_NORMAL_INPUT:
			if (is_displayable(input_char))
                                state->backend_ops->display_char(state->backend_ops->param, input_char, state);
			else if (input_char == ANSI_ESC)
			{
				state->state = VT102_STATE_ESCAPE_SEQUENCE_STARTED;
			}
			else
				/* assume this is a control character */
				handle_control_char(state, input_char);
			break;
		case VT102_STATE_ESCAPE_SEQUENCE_STARTED:
			switch (input_char)
			{
				case '[':
				/* ansi CSI (control sequence introducer)
				 * sequence detected -
				 * wait for more characters
			         * to determine the exact command
				 * requested */
					state->state = VT102_STATE_ANSI_CMD_READ;
					break;

				/*******************************/
				/* SCS - select character sets */
				/*******************************/
				case '(':
					////!!!!panic("");
					break;
				case 'N':
					/* SS2 - single shift 2 */
					panic("");
					break;
				case 'O':
					/* SS3 - single shift 3 */
					panic("");
					break;
				/*******************************/
				/*******************************/
				/*******************************/

				/*******************/
				/* cursor movement */
				/*******************/
				case 'D':
					/* IND - index; move cursor down one line
					 * in the same column - scroll if necessary */
                                        //panic("");
					break;
				case 'M':
					/* RI - reverse index; move cursor up one line
					 * in the same column - scroll if necessary */
					state->backend_ops->cursor_reverse_index(state->backend_ops->param);
					state->state = VT102_STATE_NORMAL_INPUT;
					state->cmd_idx = 0;
					break;
				case 'E':
					/* NEL - next line; move cursor down one line,
					 * to the first position - scroll if necessary */
					panic("");
					break;
				case '7':
					/* DECSC - save cursor (and attributes) */
					panic("");
					break;
				case '8':
					/* DECRC - restore cursor (and attributes) */
					panic("");
					break;
				/*******************/
				/*******************/
				/*******************/

				/*************/
				/* tab stops */
				/*************/
				case 'H':
					/* HTS - horizontal tab set (at current column) */
					panic("");
					break;
				/*************/
				/*************/
				/*************/

				/*******************/
				/* line attributes */
				/*******************/
				case '#':
					panic("");
					break;
				/*******************/
				/*******************/
				/*******************/


				/***********/
				/* reports */
				/***********/
				case 'Z':
					/* DECID - identify terminal (what are you)
					 * this is not recommended */
					panic("");
					break;
				/***********/
				/***********/
				/***********/

				/*********/
				/* reset */
				/*********/
				case 'c':
					/* RIS - reset to initial state */
					panic("");
					break;
				/*********/
				/*********/
				/*********/
				/**********************************/
				/* vt52 compatible mode - ignored */
				/**********************************/
				case '=':
				case '>':
					state->state = VT102_STATE_NORMAL_INPUT;
					state->cmd_idx = 0;
					break;
				/**********************************/
				/**********************************/
				/**********************************/

				/* unhandled codes */
				default:
					printf("%s(): unknown escape character - %c\n", __func__, input_char);
					////!!!!panic("");
					state->state = VT102_STATE_NORMAL_INPUT;
					state->cmd_idx = 0;
			}
			break;
		case VT102_STATE_ANSI_CMD_READ:
			/* an ansi command string is being read in the state->cmd
			 * buffer until a final byte is recognized (a final byte
		         * is one in the range 0x40 - 0x7e, bytes before it in
			 * the range 0x30 - 0x3f are parameter bytes, in the
			 * range 0x20 - 0x2f - intermediate bytes; if other bytes
			 * are found - the escaped command sequencer is aborted */
			if (0x30 <= input_char && input_char <= 0x3f)
			{
				/* a parameter character */
				put_in_cmd_buf(state, input_char);
			}
			else if (0x20 <= input_char && input_char <= 0x2f)
			{
				/* an intermediate character */
				/* the vt102 does not support any intermediate
				 * characters */
				put_in_cmd_buf(state, input_char);
			}
			else if (0x40 <= input_char && input_char <= 0x7e)
			{
				/* the final character */
				put_in_cmd_buf(state, input_char);
				process_ansi_cmd(state);
				/* reset the state machine to normal input state */
				state->state = VT102_STATE_NORMAL_INPUT;
				state->cmd_idx = 0;
			}
			else
			{
				/* an invalid character - abort the current
				 * command sequence */
			}
			break;
		default:
			panic("");
	}
}

/*!
 *	\fn	struct vt102_state * init_vt102(struct vt102_backend_ops * backend_ops)
 *	\brief	initializes the vt102 emulator state variables
 *
 *	\note	this function must be invoked prior to
 *		calling any other routine in this module
 *
 *	\param	backend_ops	the data structure holding
 *				the function pointers used
 *				to interface with a vt102
 *				terminal emulator backend
 *	\return	a pointer to the newly initialized vt102
 *		emulator state to be used in subsequent
 *		calls to the emulator */
struct vt102_state * init_vt102(struct vt102_backend_ops * backend_ops)
{
struct vt102_state * s;

	if (!(s = calloc(1, sizeof * s)))
		panic("");
	if (!(s->backend_ops = calloc(1, sizeof * s->backend_ops)))
		panic("");
	* s->backend_ops = * backend_ops;
	s->state = VT102_STATE_NORMAL_INPUT;
	return s;
}


/*!
 *	\fn	void destroy_vt102(struct vt102_state * state)
 *	\brief	destroys a vt102 emulator instance
 *
 *	\param	state	the state variable of the vt102
 *			terminal emulator command parser
 *	\return	none */
void destroy_vt102(struct vt102_state * state)
{
        /* nothing really to do, just destroy the backend */
        state->backend_ops->destroy_vt102_generic_backend(state->backend_ops->param);
}


/*!
 *	\fn	struct vt102_backend_ops * vt102_get_backend_ops(struct vt102_state * state);
 	\brief	retrieves the vt102_backend_ops data structure associated with a vt102 terminal emulator state variable
 *
 *	\note	the primary use for this routine is for a caller
 *		to be able to manipulate the backend function
 *		interface table (e.g. in order to change/hook
 *		some backend routines)
 *
 *	\param	state	the state variable of the vt102
 *			terminal emulator command parser
 *	\return	a pointer to the backend function interface
 *		table associated with this vt102 terminal
 *		emulator command parser state variable */
struct vt102_backend_ops * vt102_get_backend_ops(struct vt102_state * state)
{
	return state->backend_ops;
}

